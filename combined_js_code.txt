Это не код игр, а список всех файлов и их код. 
--- Combined JavaScript Code (excluding phaser.esm.js) --- 
Generated on: 11.04.2025  2:37:48,24 
 
 
=============================================================================== 
=== File: ArcController.js 
=== Path: D:\Games\TopTrack\TopTrack Maze\ArcController.js 
=============================================================================== 
 
// ArcController.js

class ArcController {
    constructor(scene, car, controlArcGraphics, trajectoryGraphics, ghostCar, snapCursor) {
        this.scene = scene;             // Ссылка на основную сцену
        this.car = car;                 // Ссылка на спрайт машины
        this.controlArcGraphics = controlArcGraphics; // Графика для дуги
        this.trajectoryGraphics = trajectoryGraphics; // Графика для траектории
        this.ghostCar = ghostCar;         // Спрайт "призрака"
        this.snapCursor = snapCursor;       // Графика для точки "примагничивания"

        this.arcParams = {};          // Параметры текущей дуги
        this.hoveredArcZone = null;   // Зона дуги под курсором
    }

    // --- Методы расчета и отрисовки состояния ---

    calculateArcGuiParams() {
        if (!this.car) return;
        // ... (код метода calculateArcGuiParams из старого GameScene) ...
        // Скопируйте сюда ВЕСЬ код метода calculateArcGuiParams
        // из вашего оригинального game.js или текущего GameScene.js
        // Убедитесь, что используются this.car, а не просто car
        // Глобальные константы (MIN_SPEED, MAX_SPEED и т.д.) должны быть доступны
        const speed = this.car.getData('speed') ?? MIN_SPEED;
        const normSpeed = Phaser.Math.Clamp((speed - MIN_SPEED) / (MAX_SPEED - MIN_SPEED), 0, 1);
        const carAngleRad = Phaser.Math.DegToRad(this.car.angle);
        const arcCenterX = this.car.x;
        const arcCenterY = this.car.y;
        const radiusFactor = SPEED_TO_GUI_RADIUS_FACTOR * normSpeed;
        const innerRadius = BASE_INNER_RADIUS_GUI + radiusFactor;
        const baseThick = ARC_THICKNESS_GUI;
        const thickReduce = baseThick * normSpeed * GUI_THICKNESS_REDUCTION_FACTOR;
        const arcThickness = Math.max(MIN_ARC_THICKNESS, baseThick - thickReduce);
        const outerRadius = innerRadius + arcThickness;
        const workingRadius = innerRadius + arcThickness * GREEN_ZONE_RATIO;
        const brakeZoneThickness = workingRadius - innerRadius;
        const neutralRadius = (brakeZoneThickness > 0)
            ? innerRadius + brakeZoneThickness / 2
            : innerRadius;
        const angleReductionMultiplier = 1 / (normSpeed * (MAX_GUI_ANGLE_REDUCTION_FACTOR - 1) + 1);
        const angleDeg = Math.max(MIN_ARC_ANGLE_DEG, BASE_ANGLE_DEG * angleReductionMultiplier);
        const halfAngleRad = Phaser.Math.DegToRad(angleDeg / 2);
        this.arcParams = {
            centerX: arcCenterX,
            centerY: arcCenterY,
            innerRadius: Math.max(0, innerRadius),
            neutralRadius: Math.max(0, neutralRadius),
            workingRadius: Math.max(0, workingRadius),
            outerRadius: Math.max(0, outerRadius),
            halfAngleRad: halfAngleRad,
            orientationRad: carAngleRad
        };
    }

    fillAnnularSector(graphics, cx, cy, innerR, outerR, startA, endA, color, alpha) {
        // ... (код метода fillAnnularSector из старого GameScene) ...
        if (!graphics || !isFinite(cx) || !isFinite(cy) || !isFinite(innerR) || !isFinite(outerR) || outerR <= innerR || innerR < 0) return;
        graphics.fillStyle(color, alpha);
        graphics.beginPath();
        graphics.arc(cx, cy, outerR, startA, endA, false);
        graphics.arc(cx, cy, innerR, endA, startA, true);
        graphics.closePath();
        graphics.fillPath();
    }

    drawControlArc() {
        // ... (код метода drawControlArc из старого GameScene) ...
        // Скопируйте сюда ВЕСЬ код метода drawControlArc
        // Используйте this.controlArcGraphics, this.car, this.arcParams, this.hoveredArcZone
        // Используйте this.fillAnnularSector(...)
        if (!this.controlArcGraphics || !this.car) return;
        const ap = this.arcParams;
        this.controlArcGraphics.clear();
        const currentSpeed = this.car.getData('speed') ?? MIN_SPEED;
        const redCooldownActive = (this.car.getData('redCooldown') ?? 0) > 0;
        const accelIsDisabled = this.car.getData('accelDisabled') ?? false;
        const hovered = this.hoveredArcZone;
        const HOVER_ALPHA = ZONE_ALPHA_HOVER;
        const DEFAULT_RED_ALPHA = ZONE_ALPHA_DEFAULT;
        const DEFAULT_ACCEL_ALPHA = ZONE_ALPHA_DEFAULT + 0.1;
        const DEFAULT_BRAKE_ALPHA = ZONE_ALPHA_DEFAULT + 0.1;
        const DEFAULT_REVERSE_ALPHA = ZONE_ALPHA_DEFAULT + 0.2;

        if (ap && ap.outerRadius > ap.innerRadius && ap.halfAngleRad > 0 && ap.innerRadius >= 0) {
            const startAngle = ap.orientationRad - ap.halfAngleRad;
            const endAngle = ap.orientationRad + ap.halfAngleRad;
            if (ap.workingRadius < ap.outerRadius && !redCooldownActive) {
                const redInnerRadius = (ap.workingRadius + ap.outerRadius) / 2;
                if (redInnerRadius < ap.outerRadius) {
                    const alpha = (hovered === 'red') ? HOVER_ALPHA : DEFAULT_RED_ALPHA;
                    this.fillAnnularSector(this.controlArcGraphics, ap.centerX, ap.centerY, redInnerRadius, ap.outerRadius, startAngle, endAngle, COLOR_RED, alpha);
                }
            }
            if (ap.neutralRadius < ap.workingRadius && !accelIsDisabled) {
                const alpha = (hovered === 'accelerate') ? HOVER_ALPHA : DEFAULT_ACCEL_ALPHA;
                this.fillAnnularSector(this.controlArcGraphics, ap.centerX, ap.centerY, ap.neutralRadius, ap.workingRadius, startAngle, endAngle, COLOR_ACCELERATE, alpha);
            }
            if (ap.innerRadius < ap.neutralRadius) {
                const alpha = (hovered === 'brake') ? HOVER_ALPHA : DEFAULT_BRAKE_ALPHA;
                this.fillAnnularSector(this.controlArcGraphics, ap.centerX, ap.centerY, ap.innerRadius, ap.neutralRadius, startAngle, endAngle, COLOR_BRAKE, alpha);
            }
        }

        if (currentSpeed === MIN_SPEED) {
            const carAngleRad = Phaser.Math.DegToRad(this.car.angle);
            const reverseOrientationRad = carAngleRad + Math.PI;
            const halfReverseAngleRad = Phaser.Math.DegToRad(REVERSE_ARC_ANGLE_DEG / 2);
            const startAngleRev = reverseOrientationRad - halfReverseAngleRad;
            const endAngleRev = reverseOrientationRad + halfReverseAngleRad;
            const innerRRev = REVERSE_ARC_INNER_RADIUS;
            const outerRRev = innerRRev + REVERSE_ARC_THICKNESS;
            const alpha = (hovered === 'reverse') ? HOVER_ALPHA : DEFAULT_REVERSE_ALPHA;
            this.fillAnnularSector(this.controlArcGraphics, this.car.x, this.car.y, innerRRev, outerRRev, startAngleRev, endAngleRev, COLOR_REVERSE, alpha);
        }
    }

    // Вычисляет все параметры и перерисовывает дугу и др. элементы управления
    // Вызывается сценой после завершения хода или при инициализации
    drawState() {
        this.calculateArcGuiParams();
        this.drawControlArc();
        // Можно добавить сброс trajectory/ghost если нужно
    }

    // Сбрасывает и очищает визуальные элементы управления (дуга, траектория...)
    // Вызывается сценой, когда машина начинает движение или игра окончена
    clearVisuals() {
        if (this.controlArcGraphics) this.controlArcGraphics.clear();
        if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
        if (this.ghostCar?.visible) this.ghostCar.setVisible(false);
        if (this.snapCursor) this.snapCursor.clear();
        this.hoveredArcZone = null;
        if (this.scene?.game?.canvas) { // Убираем кастомный курсор, если он был
             this.scene.game.canvas.style.cursor = 'default';
        }
    }

    // Сбрасывает состояние для следующего хода (вызывается из finishMove сцены)
    resetForNextTurn(pointer) {
        this.drawState();
        // Обновляем состояние ховера/призрака на основе текущей позиции курсора
        if (pointer) {
            this.handlePointerMove(pointer);
        }
    }


    // --- Методы обработки ввода ---

    getArcZoneForPoint(pointX, pointY) {
        // ... (код метода getArcZoneForPoint из старого GameScene) ...
        // Скопируйте сюда ВЕСЬ код метода getArcZoneForPoint
        // Используйте this.car, this.arcParams
        if (!this.car) return null; // Добавим проверку
        const currentSpeed = this.car.getData('speed') ?? MIN_SPEED;
        const dx = pointX - this.car.x;
        const dy = pointY - this.car.y;
        const distSqr = dx * dx + dy * dy;
        const pointAngleRad = Math.atan2(dy, dx);
        const carAngleRad = Phaser.Math.DegToRad(this.car.angle);

        if (currentSpeed === MIN_SPEED) {
            const reverseOrientationRad = carAngleRad + Math.PI;
            const halfReverseAngleRad = Phaser.Math.DegToRad(REVERSE_ARC_ANGLE_DEG / 2);
            const innerRRev = REVERSE_ARC_INNER_RADIUS;
            const outerRRev = innerRRev + REVERSE_ARC_THICKNESS;
            if (distSqr >= innerRRev * innerRRev && distSqr <= outerRRev * outerRRev) {
                const relativeAngleRadRev = Phaser.Math.Angle.Wrap(pointAngleRad - reverseOrientationRad);
                if (Math.abs(relativeAngleRadRev) <= halfReverseAngleRad) return 'reverse';
            }
        }

        const ap = this.arcParams;
        if (!ap || ap.innerRadius < 0 || ap.outerRadius <= ap.innerRadius) return null;
        if (distSqr < ap.innerRadius * ap.innerRadius || distSqr > ap.outerRadius * ap.outerRadius) return null;
        const relativeAngleRadFwd = Phaser.Math.Angle.Wrap(pointAngleRad - ap.orientationRad);
        if (Math.abs(relativeAngleRadFwd) > ap.halfAngleRad) return null;
        const actualRedInnerRadius = (ap.workingRadius + ap.outerRadius) / 2;

        const redCooldownActive = (this.car.getData('redCooldown') ?? 0) > 0;
        const accelIsDisabled = this.car.getData('accelDisabled') ?? false;
        if (distSqr <= ap.neutralRadius * ap.neutralRadius) {
            return 'brake';
        } else if (distSqr <= ap.workingRadius * ap.workingRadius) {
            return accelIsDisabled ? null : 'accelerate';
        } else if (distSqr < actualRedInnerRadius * actualRedInnerRadius) {
             // Мертвая зона между accelerate/red
            return null;
        } else { // distSqr >= actualRedInnerRadius * actualRedInnerRadius
            return redCooldownActive ? null : 'red';
        }
    }

    getSnapPointForForwardArc(pointerX, pointerY) {
        // ... (код метода getSnapPointForForwardArc из старого GameScene) ...
         // Если курсор находится внутри активной арки – снапинг не применяется.
        if (this.getArcZoneForPoint(pointerX, pointerY) !== null) {
            return null;
        }

        const cx = this.car.x;
        const cy = this.car.y;

        // Вычисляем расстояние и угол от центра машины до курсора.
        const dx = pointerX - cx;
        const dy = pointerY - cy;
        // const pointerDist = Math.sqrt(dx * dx + dy * dy); // Не используется напрямую здесь
        const pointerAngle = Math.atan2(dy, dx);

        // Получаем параметры арки
        const ap = this.arcParams;
        if (!ap || !this.car) return null; // Добавил проверку this.car

        const orientation = ap.orientationRad;
        const halfAngle = ap.halfAngleRad;
        const globalStartAngle = orientation - halfAngle;
        const globalEndAngle = orientation + halfAngle;

        // Локальный хелпер для проверки, находится ли угол внутри диапазона.
        const angleWithin = (angle, start, end) => {
            let a = Phaser.Math.Angle.Normalize(angle);
            let s = Phaser.Math.Angle.Normalize(start);
            let e = Phaser.Math.Angle.Normalize(end);
            if (s <= e) {
                return a >= s && a <= e;
            } else { // Угол пересекает 0/2PI
                return a >= s || a <= e;
            }
        };

        const redCooldownActive = (this.car.getData('redCooldown') ?? 0) > 0;
        const accelIsDisabled = this.car.getData('accelDisabled') ?? false;

        let candidates = [];

        // Добавляем границы зон в кандидаты для "примагничивания"
        if (ap.innerRadius >= 0 && ap.neutralRadius > ap.innerRadius) {
            candidates.push({ zone: 'brake', radius: ap.innerRadius });
            candidates.push({ zone: 'brake', radius: ap.neutralRadius });
        }
        if (ap.neutralRadius >= 0 && ap.workingRadius > ap.neutralRadius && !accelIsDisabled) {
            // Используем ту же границу neutralRadius, что и у brake
            // candidates.push({ zone: 'accelerate', radius: ap.neutralRadius }); // Уже есть от brake
            candidates.push({ zone: 'accelerate', radius: ap.workingRadius });
        }
        if (ap.workingRadius >= 0 && ap.outerRadius > ap.workingRadius && !redCooldownActive) {
            const actualRedInnerRadius = (ap.workingRadius + ap.outerRadius) / 2;
             if (actualRedInnerRadius > ap.workingRadius) { // Проверка, что red зона вообще есть
                // Используем ту же границу workingRadius, что и у accelerate
                // candidates.push({ zone: 'red', radius: ap.workingRadius }); // Уже есть от accelerate
                candidates.push({ zone: 'red', radius: actualRedInnerRadius });
                candidates.push({ zone: 'red', radius: ap.outerRadius });
             }
        }

        // Выбираем кандидата, к которому курсор ближе.
        let bestCandidate = null;
        let minDistance = Number.MAX_VALUE;
        for (let candidate of candidates) {
            let candidateAngle = pointerAngle;
            // Проверяем, нужно ли снапить угол к границе дуги
            if (!angleWithin(pointerAngle, globalStartAngle, globalEndAngle)) {
                 let diffStart = Math.abs(Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(pointerAngle), Phaser.Math.RadToDeg(globalStartAngle)));
                 let diffEnd = Math.abs(Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(pointerAngle), Phaser.Math.RadToDeg(globalEndAngle)));

                 // Снапим к ближайшей угловой границе
                candidateAngle = (diffStart < diffEnd) ? globalStartAngle : globalEndAngle;
            }
            // Вычисляем координаты кандидата на окружности с данным радиусом и (возможно снапнутым) углом.
            const candidateX = cx + Math.cos(candidateAngle) * candidate.radius;
            const candidateY = cy + Math.sin(candidateAngle) * candidate.radius;
            const dist = Phaser.Math.Distance.Between(pointerX, pointerY, candidateX, candidateY);
            if (dist < minDistance) {
                minDistance = dist;
                bestCandidate = { snapX: candidateX, snapY: candidateY, zone: candidate.zone };
            }
        }

        // Если минимальное расстояние от курсора до кандидата меньше порога, возвращаем его.
        if (bestCandidate && minDistance <= SNAP_THRESHOLD) {
            return bestCandidate;
        }

        return null;
    }

    getSnapPointForReverseArc(pointerX, pointerY) {
        // ... (код метода getSnapPointForReverseArc из старого GameScene) ...
        const cx = this.car.x;
        const cy = this.car.y;

        // Определяем ориентацию реверс-арки: это угол машины + 180°
        const carAngleRad = Phaser.Math.DegToRad(this.car.angle);
        const reverseOrientation = carAngleRad + Math.PI;
        const halfReverseAngle = Phaser.Math.DegToRad(REVERSE_ARC_ANGLE_DEG / 2);
        const startAngle = reverseOrientation - halfReverseAngle;
        const endAngle = reverseOrientation + halfReverseAngle;

        // Вычисляем расстояние и угол от центра машины до курсора
        const dx = pointerX - cx;
        const dy = pointerY - cy;
        // const pointerDist = Math.sqrt(dx * dx + dy * dy); // Не используется
        const pointerAngle = Math.atan2(dy, dx);

        // Определяем радиусы реверс-арки (фиксированные)
        const innerRRev = REVERSE_ARC_INNER_RADIUS;
        const outerRRev = innerRRev + REVERSE_ARC_THICKNESS;

        // Если курсор уже находится внутри реверс-арки (по базовой логике getArcZoneForPoint),
        // то снап не нужен.
        if (this.getArcZoneForPoint(pointerX, pointerY) === 'reverse') {
            return null;
        }

        // Локальный helper для проверки, находится ли угол внутри заданного диапазона.
        const angleWithin = (angle, start, end) => {
            let a = Phaser.Math.Angle.Normalize(angle);
            let s = Phaser.Math.Angle.Normalize(start);
            let e = Phaser.Math.Angle.Normalize(end);
            if (s <= e) {
                return a >= s && a <= e;
            } else { // Угол пересекает 0/2PI
                return a >= s || a <= e;
            }
        };

        // Собираем кандидатов для снапа по границам реверс-арки
        let candidates = [
            { zone: 'reverse', radius: innerRRev },
            { zone: 'reverse', radius: outerRRev }
        ];

        let bestCandidate = null;
        let minDistance = Number.MAX_VALUE;

        // Ищем ближайшего кандидата
        for (let candidate of candidates) {
            let candidateAngle = pointerAngle;
            // Проверяем, нужно ли снапить угол к границе дуги
            if (!angleWithin(pointerAngle, startAngle, endAngle)) {
                 let diffStart = Math.abs(Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(pointerAngle), Phaser.Math.RadToDeg(startAngle)));
                 let diffEnd = Math.abs(Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(pointerAngle), Phaser.Math.RadToDeg(endAngle)));
                // Снапим к ближайшей угловой границе
                candidateAngle = (diffStart < diffEnd) ? startAngle : endAngle;
            }
            const candidateX = cx + Math.cos(candidateAngle) * candidate.radius;
            const candidateY = cy + Math.sin(candidateAngle) * candidate.radius;
            const dist = Phaser.Math.Distance.Between(pointerX, pointerY, candidateX, candidateY);
            if (dist < minDistance) {
                minDistance = dist;
                bestCandidate = { snapX: candidateX, snapY: candidateY, zone: candidate.zone };
            }
        }

        if (bestCandidate && minDistance <= SNAP_THRESHOLD) {
            return bestCandidate;
        }
        return null;
    }


    handlePointerMove(pointer) {
        // ... (код метода handlePointerMove из старого GameScene, НО без проверок isMoving/levelComplete/gameOver) ...
        // Эти проверки теперь делает сама сцена перед вызовом этого метода
        // Скопируйте сюда логику метода handlePointerMove, начиная с:
        // if (!this.trajectoryGraphics || !this.ghostCar || !this.controlArcGraphics) return;
        // Используйте this.scene, this.car, this.getArcZoneForPoint, this.getSnapPoint..., this.drawControlArc,
        // this.ghostCar, this.trajectoryGraphics, this.snapCursor, this.drawTrajectory,
        // this.calculateTargetFromArcPoint
        if (!this.trajectoryGraphics || !this.ghostCar || !this.controlArcGraphics || !this.car) return;
        const pointerX = pointer.worldX;
        const pointerY = pointer.worldY;

        let snapResult = null;
        let newZone = this.getArcZoneForPoint(pointerX, pointerY);

        // Если указатель вне арки – проверяем, попадает ли он в магнитную зону.
        if (!newZone) {
            // Если машина стоит на месте, проверяем реверс-арку
            if (this.car.getData('speed') === MIN_SPEED) {
                snapResult = this.getSnapPointForReverseArc(pointerX, pointerY);
                if (snapResult) {
                    newZone = snapResult.zone;
                }
            }
            // Если не нашли в реверсе (или машина не стоит), проверяем основную арку
            if (!newZone) {
                snapResult = this.getSnapPointForForwardArc(pointerX, pointerY);
                if (snapResult) {
                    newZone = snapResult.zone;
                }
            }
        }

        // Если зона изменилась, обновляем ее и перерисовываем дугу
        if (newZone !== this.hoveredArcZone) {
            this.hoveredArcZone = newZone;
            this.drawControlArc(); // Перерисовываем дугу с новым ховером
        }

        // Если курсор находится в активной зоне (или был примагничен)
        if (this.hoveredArcZone) {
            // Прячем системный курсор (можно настроить)
            // this.scene.game.canvas.style.cursor = 'none';
             this.scene.game.canvas.style.cursor = 'pointer'; // Или 'pointer'

            // Определяем точку для отображения (либо реальный курсор, либо точка примагничивания)
            let displayX = (snapResult && snapResult.snapX !== undefined) ? snapResult.snapX : pointerX;
            let displayY = (snapResult && snapResult.snapY !== undefined) ? snapResult.snapY : pointerY;

            // Рисуем кастомный курсор (белую точку) в точке отображения
            if (this.snapCursor) {
                this.snapCursor.clear();
                this.snapCursor.fillStyle(0xffffff, 1);
                this.snapCursor.fillCircle(displayX, displayY, 3.5); // Немного увеличил
            }

            // --- Отображаем призрак и траекторию ---
            let targetX, targetY, targetAngleRad;
            const carAngleRad = Phaser.Math.DegToRad(this.car.angle);

            if (this.hoveredArcZone === 'reverse') {
                // Для реверса цель всегда одна и та же
                const reverseAngleRad = carAngleRad + Math.PI;
                targetX = this.car.x + Math.cos(reverseAngleRad) * REVERSE_MOVE_DISTANCE;
                targetY = this.car.y + Math.sin(reverseAngleRad) * REVERSE_MOVE_DISTANCE;
                targetAngleRad = carAngleRad; // Машина не поворачивается при реверсе
            } else {
                // Для остальных зон цель зависит от точки на дуге (displayX, displayY)
                const targetData = this.calculateTargetFromArcPoint(displayX, displayY);
                if (targetData) {
                    targetX = targetData.targetX;
                    targetY = targetData.targetY;
                    targetAngleRad = targetData.targetAngleRad;
                } else {
                    // Если не удалось рассчитать цель, скрываем все
                    this.ghostCar.setVisible(false);
                    this.trajectoryGraphics.clear();
                    return;
                }
            }

            // Обновляем позицию и угол призрака и делаем его видимым
            if (this.ghostCar) {
                this.ghostCar.setPosition(targetX, targetY)
                    .setAngle(Phaser.Math.RadToDeg(targetAngleRad))
                    .setVisible(true);
            }
            // Рисуем траекторию
            this.drawTrajectory(this.car.x, this.car.y, targetX, targetY);

        } else { // Если курсор вне активной зоны
            if (this.ghostCar) this.ghostCar.setVisible(false);
            if (this.trajectoryGraphics) this.trajectoryGraphics.clear();
            if (this.snapCursor) this.snapCursor.clear();
            if (this.scene.game.canvas) this.scene.game.canvas.style.cursor = 'default';
        }

    }


    // --- Методы расчета движения ---

    drawTrajectory(startX, startY, endX, endY) {
        // ... (код метода drawTrajectory из старого GameScene) ...
        if (!this.trajectoryGraphics) return;
        this.trajectoryGraphics.clear().lineStyle(2, TRAJECTORY_COLOR, TRAJECTORY_ALPHA);
        const dist = Phaser.Math.Distance.Between(startX, startY, endX, endY);
        const angle = Phaser.Math.Angle.Between(startX, startY, endX, endY);
        const dashLen = TRAJECTORY_DASH_LENGTH;
        const gapLen = TRAJECTORY_GAP_LENGTH;
        const totalPatternLen = dashLen + gapLen;
        let currentDist = 0;
        this.trajectoryGraphics.beginPath();
        while (currentDist < dist) {
            const dStartX = startX + Math.cos(angle) * currentDist;
            const dStartY = startY + Math.sin(angle) * currentDist;
            const dEndX = startX + Math.cos(angle) * Math.min(currentDist + dashLen, dist);
            const dEndY = startY + Math.sin(angle) * Math.min(currentDist + dashLen, dist);
            this.trajectoryGraphics.moveTo(dStartX, dStartY).lineTo(dEndX, dEndY);
            currentDist += totalPatternLen;
        }
        this.trajectoryGraphics.strokePath();
    }

    calculateTargetFromArcPoint(arcPointX, arcPointY) {
        // ... (код метода calculateTargetFromArcPoint из старого GameScene) ...
        // Скопируйте сюда ВЕСЬ код метода calculateTargetFromArcPoint
        // Используйте this.car, this.arcParams
         if (!this.car || !this.arcParams?.innerRadius) return null;
        const ap = this.arcParams;
        const currentSpeed = this.car.getData('speed') ?? MIN_SPEED;

        // Угол от центра машины к точке на дуге - это угол поворота
        const targetAngleRad = Phaser.Math.Angle.Between(this.car.x, this.car.y, arcPointX, arcPointY);

        // Расстояние от центра машины до точки клика на дуге
        const clickDistanceCarCenter = Phaser.Math.Distance.Between(this.car.x, this.car.y, arcPointX, arcPointY);

        // Нормализуем позицию клика относительно всей толщины дуги (от 0 до 1)
        let relativeClickDistOverallArc = 0.5; // По умолчанию середина
        const arcThickness = ap.outerRadius - ap.innerRadius;
        if (arcThickness > 0) {
            relativeClickDistOverallArc = Phaser.Math.Clamp((clickDistanceCarCenter - ap.innerRadius) / arcThickness, 0, 1);
        }

         // Нормализуем позицию клика относительно "рабочей" зоны (accelerate/brake) от -1 до 1
         // где -1 - край brake, 0 - neutral, 1 - край accelerate
        let relativeClickDistInWorkingZone = 0;
        const workingZoneThickness = ap.workingRadius - ap.innerRadius; // Полная толщина brake + accelerate
        if (workingZoneThickness > 0) {
             // Расстояние от нейтральной линии (0 соответствует ap.neutralRadius)
             const distFromNeutral = clickDistanceCarCenter - ap.neutralRadius;
             // Нормализуем относительно половины толщины рабочей зоны
             const halfWorkingThickness = (ap.workingRadius - ap.neutralRadius); // толщина accelerate
             if (halfWorkingThickness > 0 && distFromNeutral > 0) { // accelerate zone
                relativeClickDistInWorkingZone = Phaser.Math.Clamp(distFromNeutral / halfWorkingThickness, 0, 1);
             } else { // brake zone (distFromNeutral <= 0)
                const halfBrakeThickness = (ap.neutralRadius - ap.innerRadius); // толщина brake
                if (halfBrakeThickness > 0) {
                     relativeClickDistInWorkingZone = Phaser.Math.Clamp(distFromNeutral / halfBrakeThickness, -1, 0);
                }
             }
        }

        // Рассчитываем дистанцию хода
        const currentMidRadius = ap.innerRadius + arcThickness / 2; // Средний радиус текущей дуги
        // Базовая дистанция зависит от относительного положения клика на всей дуге
        const baseDist = Phaser.Math.Linear(MIN_MOVE_DISTANCE_FACTOR * currentMidRadius, MAX_MOVE_DISTANCE_FACTOR * currentMidRadius, relativeClickDistOverallArc);
        // Добавляем бонус от скорости
        const totalMoveDist = baseDist + currentSpeed * SPEED_TO_DISTANCE_MULTIPLIER;

        // Рассчитываем координаты цели
        const targetX = this.car.x + Math.cos(targetAngleRad) * totalMoveDist;
        const targetY = this.car.y + Math.sin(targetAngleRad) * totalMoveDist;

        return {
            targetX,
            targetY,
            targetAngleRad, // Угол, куда машина должна повернуться
            relativeClickDistOverallArc, // Для расчета скорости анимации
            relativeClickDistInWorkingZone // Для расчета изменения скорости машины
        };
    }

    // --- Методы инициации движения ---

    // Обрабатывает клик, определяет зону и вызывает соответствующий метод движения
    // Возвращает данные о ходе для истории или null, если ход не начат
    handleSceneClick(pointer) {
        // ... (код метода handleSceneClick из старого GameScene, НО без проверок isMoving/fuel/gameOver) ...
        // Эти проверки делает сцена перед вызовом
        // Должен возвращать объект с данными для истории или null
        const clickX = pointer.worldX;
        const clickY = pointer.worldY;

        let snapResult = null;
        let effectiveX = clickX;
        let effectiveY = clickY;

        // Определяем зону клика, учитывая "примагничивание"
        let clickArcZone = this.getArcZoneForPoint(clickX, clickY);
        if (!clickArcZone) {
            // Если вне арки – проверяем магнитный эффект для реверс-арки (если applicable)
            if (this.car.getData('speed') === MIN_SPEED) {
                snapResult = this.getSnapPointForReverseArc(clickX, clickY);
                if (snapResult) {
                    clickArcZone = snapResult.zone;
                    effectiveX = snapResult.snapX;
                    effectiveY = snapResult.snapY;
                }
            }
            // Если не реверс, проверяем основную арку
            if (!clickArcZone) {
                snapResult = this.getSnapPointForForwardArc(clickX, clickY);
                if (snapResult) {
                    clickArcZone = snapResult.zone;
                    effectiveX = snapResult.snapX;
                    effectiveY = snapResult.snapY;
                }
            }
        }

        let moveData = null;
        if (clickArcZone) {
            if (clickArcZone === 'reverse') {
                console.log("Controller: Clicked REVERSE arc");
                const reverseAngleRad = Phaser.Math.DegToRad(this.car.angle + 180);
                const targetX = this.car.x + Math.cos(reverseAngleRad) * REVERSE_MOVE_DISTANCE;
                const targetY = this.car.y + Math.sin(reverseAngleRad) * REVERSE_MOVE_DISTANCE;
                moveData = this.initiateReverseMove(targetX, targetY); // Вызываем внутренний метод
            } else {
                const targetData = this.calculateTargetFromArcPoint(effectiveX, effectiveY);
                if (targetData) {
                     moveData = this.initiateForwardMove( // Вызываем внутренний метод
                        targetData.targetX,
                        targetData.targetY,
                        clickArcZone,
                        targetData.relativeClickDistOverallArc,
                        targetData.relativeClickDistInWorkingZone
                    );
                 }
            }
        }

        if (moveData) {
             this.clearVisuals(); // Очищаем дугу, траекторию и т.д. при начале хода
             return { moveData }; // Возвращаем данные для истории
        }
        return null; // Ход не начат
    }


    initiateForwardMove(targetX, targetY, clickArcZone, relativeClickDistOverallArc, relativeClickDistInWorkingZone) {
         // ... (код метода handleMove из старого GameScene, НО без установки isMoving и без расхода топлива) ...
         // Должен возвращать объект с данными для истории
         if (!this.car?.body) return null; // Проверка

        this.clearVisuals(); // Очищаем элементы управления

        // --- Расчет и установка данных для СЛЕДУЮЩЕГО хода ---
        const currentSpeed = this.car.getData('speed') ?? MIN_SPEED;
        let speedForNextTurn = currentSpeed;
        let nextRedCooldown = 0; // По умолчанию сбрасываем
        let nextAccelDisabled = false; // По умолчанию разрешено

        if (clickArcZone === 'accelerate' || clickArcZone === 'brake') {
            const speedFactor = (relativeClickDistInWorkingZone < 0) ? 0.75 : 1.0; // Мягче тормозим?
            const speedChange = relativeClickDistInWorkingZone * SPEED_INCREMENT * speedFactor;
            speedForNextTurn = currentSpeed + speedChange;
            // nextRedCooldown = undefined; // Явный сброс не нужен, т.к. по умолч. 0
            // nextAccelDisabled = undefined; // Явный сброс не нужен, т.к. по умолч. false
            console.log(`Controller: FORWARD Move: Click in ${clickArcZone} (RelPos: ${relativeClickDistInWorkingZone.toFixed(2)}). Speed change: ${speedChange.toFixed(2)}`);
        } else if (clickArcZone === 'red') {
            console.log("Controller: FORWARD Move: Click in RED zone. Applying boost!");
            speedForNextTurn = currentSpeed + RED_ZONE_SPEED_BOOST;
            nextRedCooldown = RED_ZONE_COOLDOWN_TURNS; // Устанавливаем кулдаун
            nextAccelDisabled = true; // Блокируем ускорение
        }
        speedForNextTurn = Phaser.Math.Clamp(speedForNextTurn, MIN_SPEED, MAX_SPEED);

        // Сохраняем планируемое состояние в данных машины
        this.car.setData('nextSpeed', speedForNextTurn);
        this.car.setData('nextRedCooldown', nextRedCooldown);
        this.car.setData('nextAccelDisabled', nextAccelDisabled);

        console.log(`Controller: FORWARD Move End: Next Turn Planned - Speed: ${speedForNextTurn.toFixed(2)}, Next Red CD: ${nextRedCooldown}, Next Accel Disabled: ${nextAccelDisabled}`);

        // --- Расчет анимации для ТЕКУЩЕГО хода ---
        const moveDistance = Phaser.Math.Distance.Between(this.car.x, this.car.y, targetX, targetY);
        const currentAngleDeg = this.car.angle;
        const angleToTargetRad = Phaser.Math.Angle.Between(this.car.x, this.car.y, targetX, targetY);
        const rawTargetAngleDeg = Phaser.Math.RadToDeg(angleToTargetRad);
        // Находим кратчайший угол поворота
        const shortestAngleDiff = Phaser.Math.Angle.ShortestBetween(currentAngleDeg, rawTargetAngleDeg);
        const finalAngleDeg = currentAngleDeg + shortestAngleDiff;

        console.log(`Controller Rotation: Current=${currentAngleDeg.toFixed(1)}, RawTarget=${rawTargetAngleDeg.toFixed(1)}, Diff=${shortestAngleDiff.toFixed(1)}, FinalTarget=${finalAngleDeg.toFixed(1)}`);

        // Анимация поворота
        this.scene.tweens.add({
            targets: this.car,
            angle: finalAngleDeg, // Поворачиваем на рассчитанный конечный угол
            duration: TURN_DURATION, // Фиксированная длительность поворота
            ease: 'Linear' // Или 'Sine.easeInOut'
        });

        // Расчет скорости анимации движения
        const normCurrentSpeed = Phaser.Math.Clamp((currentSpeed - MIN_SPEED) / (MAX_SPEED - MIN_SPEED), 0, 1);
        const animationSpeedMultiplier = Phaser.Math.Linear(MIN_ANIM_SPEED_MULTIPLIER, MAX_ANIM_SPEED_MULTIPLIER, normCurrentSpeed);
        const baseAnimSpeed = moveDistance * BASE_PHYSICS_MOVE_SPEED_FACTOR; // Базовая скорость зависит от дистанции
        // Бонус скорости от дальности клика по дуге
        const clickPosBonus = (1 + relativeClickDistOverallArc * CLICK_POS_ANIM_SPEED_FACTOR);
        const desiredPhysicsSpeed = baseAnimSpeed * clickPosBonus * animationSpeedMultiplier;
        // Финальная скорость анимации (с минимальным порогом)
        const finalAnimSpeed = Math.max(desiredPhysicsSpeed, MIN_VISUAL_ANIM_SPEED);

        console.log(`Controller Animation Speed: normCurrentSpeed=${normCurrentSpeed.toFixed(2)}, animMultiplier=${animationSpeedMultiplier.toFixed(2)}, baseAnim=${baseAnimSpeed.toFixed(2)}, clickBonus=${clickPosBonus.toFixed(2)}, finalAnimSpeed=${finalAnimSpeed.toFixed(2)}`);

        // Запуск физики движения к цели
        this.scene.physics.moveTo(this.car, targetX, targetY, finalAnimSpeed);
        // Сохраняем цель для проверки в update сцены
        if (this.scene.physics.world) {
            this.scene.physics.world.destination = new Phaser.Math.Vector2(targetX, targetY);
        }

        // Рассчитываем время движения для истории
        const moveTime = (finalAnimSpeed > 0) ? (moveDistance / finalAnimSpeed) * 1000 : 0;

        // Возвращаем данные для добавления в историю ходов
        return {
            startX: this.car.x,
            startY: this.car.y,
            fromAngleDeg: currentAngleDeg,
            finalAngleDeg, // Угол, к которому машина повернется
            targetX,
            targetY,
            turnDuration: TURN_DURATION, // Длительность поворота
            moveTime // Расчетное время движения
        };
    }

    initiateReverseMove(targetX, targetY) {
        // ... (код метода handleReverseMove из старого GameScene, НО без установки isMoving и без расхода топлива) ...
        // Должен возвращать объект с данными для истории
        if (!this.car?.body) return null;

        console.log("Controller: Executing REVERSE Move");
        this.clearVisuals(); // Очищаем элементы управления

        // Устанавливаем состояние для СЛЕДУЮЩЕГО хода (после реверса машина стоит)
        this.car.setData('nextSpeed', MIN_SPEED);
        this.car.setData('nextRedCooldown', 0); // Сбрасываем кулдаун
        this.car.setData('nextAccelDisabled', false); // Разрешаем ускорение
        console.log(`Controller: REVERSE Move: Next Turn Planned - Speed: ${MIN_SPEED.toFixed(2)}, Resetting Cooldowns.`);

        // Запускаем движение назад
        this.scene.physics.moveTo(this.car, targetX, targetY, REVERSE_SPEED_ANIMATION);
        // Сохраняем цель для проверки в update сцены
        if (this.scene.physics.world) {
            this.scene.physics.world.destination = new Phaser.Math.Vector2(targetX, targetY);
        }

        // Рассчитываем время движения для истории
        const moveDistance = Phaser.Math.Distance.Between(this.car.x, this.car.y, targetX, targetY);
        const moveTime = (REVERSE_SPEED_ANIMATION > 0) ? (moveDistance / REVERSE_SPEED_ANIMATION) * 1000 : 0;
        const currentAngleDeg = this.car.angle; // Угол не меняется

        // Возвращаем данные для добавления в историю ходов
        return {
            startX: this.car.x,
            startY: this.car.y,
            fromAngleDeg: currentAngleDeg,
            finalAngleDeg: currentAngleDeg, // Угол не меняется
            targetX,
            targetY,
            turnDuration: 0, // Поворота нет
            moveTime
        };
    }

} // Конец класса ArcController

// Важно: Если ваш проект использует модули (import/export),
// добавьте в конце файла: export default ArcController; 
 
 
=============================================================================== 
=== File: Constants.js 
=== Path: D:\Games\TopTrack\TopTrack Maze\Constants.js 
=============================================================================== 
 
// ==========================================
// --- КОНСТАНТЫ И НАСТРОЙКИ (Обновленные) ---
// ==========================================

// ОРИГИНАЛЬНЫЕ размеры "окна" (канvas) игры,
// которые мы не трогаем, чтобы интерфейс оставался как есть
const GAME_WIDTH = 1024;
const GAME_HEIGHT = 1024;
const GRID_CELL_SIZE = 32;

// Добавляем коэффициент, чтобы "мир" (уровень), объекты и машина
// были в 2 раза больше, чем раньше:
const WORLD_SCALE = 2;
const REAL_GAME_WIDTH = GAME_WIDTH * WORLD_SCALE; 
const REAL_GAME_HEIGHT = GAME_HEIGHT * WORLD_SCALE;

// --- Цвета и прозрачность ---
const COLOR_BRAKE       = 0xaaaaaa;
const COLOR_ACCELERATE  = 0xadd6dd;
const COLOR_RED         = 0x3dc9b0;
const COLOR_REVERSE     = 0xffa500;

const ZONE_ALPHA_DEFAULT     = 0.3;
const ZONE_ALPHA_HOVER       = 1.0;
const GHOST_ALPHA            = 0.4;
const TRAJECTORY_COLOR       = 0xffffff;
const TRAJECTORY_ALPHA       = 0.7;
const TRAJECTORY_DASH_LENGTH = 10;
const TRAJECTORY_GAP_LENGTH  = 5;
const CUBE_ALPHA             = 1.0;

// --- Параметры машины ---  
const carRadius            = 32;
const MIN_SPEED            = 0.1;
const MAX_SPEED            = 5.0;
const SPEED_INCREMENT      = 1;
const RED_ZONE_SPEED_BOOST = 2;
const RED_ZONE_COOLDOWN_TURNS = 2;

// --- Параметры арки (GUI) ---
const BASE_INNER_RADIUS_GUI           = 30;
const ARC_THICKNESS_GUI               = 50;
const GREEN_ZONE_RATIO                = 0.6;
const BASE_ANGLE_DEG                  = 120;
const SNAP_THRESHOLD = 5; // порог магнитного эффекта в пикселях
const ANGLE_SNAP_THRESHOLD = Phaser.Math.DegToRad(15);
const GAP_SNAP_THRESHOLD = 15; 

// --- Факторы влияния скорости на ВИД арки (GUI) ---
const SPEED_TO_GUI_RADIUS_FACTOR      = 40;
const GUI_THICKNESS_REDUCTION_FACTOR  = 0.1;
const MAX_GUI_ANGLE_REDUCTION_FACTOR  = 5;
const MIN_ARC_ANGLE_DEG               = 25;
const MIN_ARC_THICKNESS               = 20;

// --- Параметры арки ЗАДНЕГО ХОДА (GUI) ---
const REVERSE_ARC_INNER_RADIUS  = 25;
const REVERSE_ARC_THICKNESS     = 35;
const REVERSE_ARC_ANGLE_DEG     = 20;

// --- Параметры расчета ДИСТАНЦИИ хода ---
const MIN_MOVE_DISTANCE_FACTOR  = 0.5;
const MAX_MOVE_DISTANCE_FACTOR  = 2.5;
const SPEED_TO_DISTANCE_MULTIPLIER = 15;

// --- Параметры движения и скорости ---
const BASE_PHYSICS_MOVE_SPEED_FACTOR = 1.0;
const CLICK_POS_ANIM_SPEED_FACTOR    = 0.8;
const MIN_ANIM_SPEED_MULTIPLIER      = 0.8;
const MAX_ANIM_SPEED_MULTIPLIER      = 3.5;
const MIN_VISUAL_ANIM_SPEED          = 50;
const TURN_DURATION                  = 300;
const STOP_DISTANCE_THRESHOLD        = 5;
const MIN_STOP_SPEED                 = 0;

// --- Параметры движения ЗАДНИМ ХОДОМ ---
const REVERSE_MOVE_DISTANCE     = GRID_CELL_SIZE * 1.5;
const REVERSE_SPEED_ANIMATION   = 50;

// --- Параметры генерации уровня ---
const NOISE_SCALE                = 150;
const START_AREA_CLEAR_RADIUS_FACTOR = 3;

// Портал
const PORTAL_KEY                 = 'portal';

// --- Параметры препятствий и другие ---
const CUBE_SIZE_FACTOR           = 0.8;
const OBSTACLE_THRESHOLD_DECREMENT = 0.05;
const MIN_OBSTACLE_THRESHOLD     = 0.2;
const TOTAL_LEVELS               = 10;
const INITIAL_OBSTACLE_THRESHOLD = 0.7;

// --- КЛЮЧИ для загруженных ассетов ---
const SAND_TEXTURE_KEY       = 'sandTexture';
const OBSTACLE_IMAGE_KEY     = 'obstacleBlock';
const MAIN_BG_KEY            = 'mainBg';
const START_BUTTON_KEY       = 'startButton';
const CAR_PLAYER_KEY         = 'car_player';
const RESTART_BUTTON_KEY     = 'restartButton';
const NEXT_LEVEL_BUTTON_KEY  = 'nextLevelButton';
const FUEL_PICKUP_KEY        = 'fuelPickup';

// --- Параметры прогрессии ---
const INITIAL_FUEL           = 10;
const FUEL_CONSUMPTION_PER_MOVE = 1;
const FUEL_GAIN_ON_PICKUP    = 5;
const FUEL_LOW_THRESHOLD     = 3;
const FUEL_COLOR_NORMAL      = '#ffffff';
const FUEL_COLOR_LOW         = '#ff0000';

// --- Параметры эффектов ---
const FLASH_DURATION         = 300;
const FLASH_COLOR            = 0xff0000;
const WIN_FLASH_COLOR        = 0x00ff00;
const SHAKE_DURATION         = 300;
const SHAKE_INTENSITY        = 0.01;
const RESTART_DELAY          = 1000; 
 
 
=============================================================================== 
=== File: GameScene.js 
=== Path: D:\Games\TopTrack\TopTrack Maze\GameScene.js 
=============================================================================== 
 
// GameScene.js (После вынесения логики в ArcController.js)

class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        this.car = null;
        // Графика и объекты, управляемые ArcController
        this.controlArcGraphics = null;
        this.trajectoryGraphics = null;
        this.ghostCar = null;
        this.snapCursor = null;
        // Контроллер
        this.arcController = null; // Ссылка на экземпляр ArcController

        // Остальные свойства сцены
        this.infoText = null;
        this.levelText = null;
        this.fuelText = null;
        this.isMoving = false;
        this.obstaclesGroup = null;
        this.collectibleGroup = null;
        this.fuelPickupGroup = null;
        this.cube = null; // Портал
        this.portalArrow = null;
        this.noise = null;
        this.winText = null;
        this.nextLevelButton = null;
        this.restartLevelText = null;
        this.levelComplete = false;
        this.playAgainButton = null;
        this.gameOver = false;
        this.backgroundTile = null;
        this.restartButtonObject = null;
        this.prevDistanceToTarget = undefined; // Для детекции промаха moveTo

        // Параметры уровня и прогрессии
        this.currentLevel = 1;
        this.currentObstacleThreshold = INITIAL_OBSTACLE_THRESHOLD;
        this.fuel = INITIAL_FUEL;

        // Для генерации
        this.occupiedCellsForSpawning = null;
        this.gridWidthForSpawning = 0;
        this.gridHeightForSpawning = 0;

        // Для реплея
        this.movesHistory = [];
        this.replayCar = null;
        this.currentReplayIndex = 0;

        // Камеры
        this.uiCamera = null;
    }

    startNewGame() {
        console.log("Starting New Game from Win screen...");
        this.registry.set('currentLevel', 1);
        this.registry.set('obstacleThreshold', INITIAL_OBSTACLE_THRESHOLD);

        if (this.scene.isActive(this.scene.key)) {
            this.scene.start('MainMenuScene');
        }
    }

    preload() {
        console.log("Preloading GameScene assets...");
        // Ассеты, не связанные напрямую с ArcController
        this.load.image(CAR_PLAYER_KEY, 'assets/car_player.png');
        this.load.image(SAND_TEXTURE_KEY, 'assets/sand_texture.jpg');
        this.load.image(OBSTACLE_IMAGE_KEY, 'assets/block.png');
        this.load.image(RESTART_BUTTON_KEY, 'assets/restart.png');
        this.load.image(NEXT_LEVEL_BUTTON_KEY, 'assets/NEXTLEVEL.png');
        this.load.image(FUEL_PICKUP_KEY, 'assets/fuel.png');
        this.load.image(PORTAL_KEY, 'assets/portal.png');
        this.load.image('arrow', 'assets/arrow.png');
    }

    create() {
        console.log("Phaser version:", Phaser.VERSION);

        // Сброс состояния перед стартом/рестартом
        this.movesHistory = [];
        this.currentLevel = this.registry.get('currentLevel') || 1;
        this.currentObstacleThreshold = this.registry.get('obstacleThreshold') || INITIAL_OBSTACLE_THRESHOLD;
        this.fuel = INITIAL_FUEL;
        this.levelComplete = false;
        this.gameOver = false;
        this.isMoving = false;
        this.arcController = null; // Сбрасываем контроллер

        console.log(`Creating scene for Level ${this.currentLevel}... Obstacle Threshold: ${this.currentObstacleThreshold.toFixed(2)}`);

        // --- Инициализация Simplex Noise ---
        if (typeof SimplexNoise === 'undefined') {
            console.error("SimplexNoise library not found!");
            // Отображение ошибки, если нужно
            return;
        }
        this.noise = new SimplexNoise();

        // --- Настройка мира и камеры ---
        this.physics.world.setBounds(0, 0, REAL_GAME_WIDTH, REAL_GAME_HEIGHT);
        this.cameras.main.setBounds(0, 0, REAL_GAME_WIDTH, REAL_GAME_HEIGHT);

        // --- Фон ---
        this.backgroundTile = this.add.tileSprite(0, 0, REAL_GAME_WIDTH, REAL_GAME_HEIGHT, SAND_TEXTURE_KEY)
            .setOrigin(0, 0)
            .setDepth(-20);

        // --- Группы объектов ---
        this.obstaclesGroup = this.physics.add.staticGroup();
        this.collectibleGroup = this.physics.add.group(); // Для портала
        this.fuelPickupGroup = this.physics.add.group(); // Для топлива

        // --- Генерация уровня ---
        this.createLevel(); // Использует this.noise, this.obstaclesGroup, this.collectibleGroup

        // --- Создание машины ---
        this.car = this.physics.add.sprite(REAL_GAME_WIDTH / 2, REAL_GAME_HEIGHT / 2, CAR_PLAYER_KEY);
        this.car.setScale(0.3).setOrigin(0.5, 0.5).setDataEnabled();
        this.car.setData({
            speed: MIN_SPEED,
            nextSpeed: undefined,
            redCooldown: 0,
            nextRedCooldown: undefined,
            accelDisabled: false,
            nextAccelDisabled: undefined
        });
        this.car.angle = -90; // Начальный угол
        this.car.body.setCircle(carRadius); // Настройка коллайдера
        this.car.body.setOffset(70, 20);
        this.car.setCollideWorldBounds(true).setDepth(10);

        // --- Спавн топлива ---
        for (let i = 0; i < 10; i++) { // Спавним N канистр
             this.spawnFuelPickup(this.occupiedCellsForSpawning, this.gridWidthForSpawning, this.gridHeightForSpawning);
        }

        // --- Создание графики и объектов для ArcController ---
        this.controlArcGraphics = this.add.graphics().setDepth(5);
        this.trajectoryGraphics = this.add.graphics().setDepth(6);
        this.ghostCar = this.add.sprite(0, 0, CAR_PLAYER_KEY)
             .setOrigin(0.5, 0.5)
             .setScale(this.car.scale)
             .setAlpha(GHOST_ALPHA)
             .setVisible(false)
             .setDepth(7);
        this.snapCursor = this.add.graphics().setDepth(50); // Графика для точки примагничивания

        // --- Создание и инициализация ArcController ---
        this.arcController = new ArcController(
            this,                    // Ссылка на сцену
            this.car,                // Ссылка на машину
            this.controlArcGraphics, // Графика дуги
            this.trajectoryGraphics, // Графика траектории
            this.ghostCar,           // Призрак машины
            this.snapCursor          // Точка примагничивания
        );
        console.log("ArcController initialized.");

        // --- Элементы UI (создаются здесь, управляются из сцены) ---
        this.infoText = this.add.text(10, 10, '', { /* ... стили ... */ }).setDepth(20);
        this.levelText = this.add.text(200, 5, `Level ${this.currentLevel} / ${TOTAL_LEVELS}`, { /* ... стили ... */ }).setOrigin(0, 0).setDepth(21);
        this.fuelText = this.add.text(GAME_WIDTH / 2, 5, '', { /* ... стили ... */ }).setOrigin(0.5, 0).setDepth(21);
        this.updateFuelDisplay(); // Первоначальное отображение топлива

        // Кнопки победы/поражения и рестарта
        this.playAgainButton = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30, START_BUTTON_KEY)
             /* ... настройки ... */ .setVisible(false).setInteractive({ useHandCursor: true })
             .on('pointerdown', this.startNewGame, this);

        const restartButtonX = GAME_WIDTH - 5;
        const restartButtonY = 5;
        this.restartButtonObject = this.add.image(restartButtonX, restartButtonY, RESTART_BUTTON_KEY)
            .setOrigin(1, 0).setDepth(22).setInteractive({ useHandCursor: true });
        this.restartButtonObject.on('pointerdown', () => {
            console.log("Restart button clicked!");
            if (!this.isMoving && !this.levelComplete && !this.gameOver) {
                this.scene.restart();
            }
        });

        this.winText = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50, 'LEVEL COMPLETE!', { /* ... стили ... */})
             .setOrigin(0.5).setDepth(25).setVisible(false);

        this.nextLevelButton = null; // Создаем, только если не последний уровень
        if (this.currentLevel < TOTAL_LEVELS) {
             this.nextLevelButton = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30, NEXT_LEVEL_BUTTON_KEY)
                /* ... настройки ... */.setVisible(false).setInteractive({ useHandCursor: true })
                .on('pointerdown', this.startNextLevel, this);
        }

        this.restartLevelText = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, '', { /* ... стили ... */})
            .setOrigin(0.5).setDepth(26).setVisible(false);

        // --- Обработчики ввода (Делегирование ArcController) ---
        this.input.off('pointerdown'); // Очищаем старые обработчики на всякий случай
        this.input.off('pointermove');

        this.input.on('pointermove', (pointer) => {
            // Если игра активна и контроллер есть, передаем ему событие
            if (!this.isMoving && !this.levelComplete && !this.gameOver && this.arcController) {
                this.arcController.handlePointerMove(pointer);
            } else if (this.arcController) {
                 // Если игра неактивна, но контроллер есть, убедимся, что его визуалы скрыты
                 this.arcController.clearVisuals();
            }
        }, this);

        this.input.on('pointerdown', (pointer) => {
            // 1. Проверяем состояние игры (включая топливо)
            if (this.isMoving || this.levelComplete || this.gameOver || !this.car || !this.arcController) {
                return; // Игнорируем клик, если игра не готова
            }
            if (this.fuel <= 0) {
                this.handleOutOfFuel(); // Проверяем топливо ПЕРЕД вызовом контроллера
                return;
            }

            // 2. Просим контроллер обработать клик
            const result = this.arcController.handleSceneClick(pointer);

            // 3. Если контроллер инициировал ход (вернул данные)
            if (result && result.moveData) {
                // Расходуем топливо (логика сцены)
                this.fuel -= FUEL_CONSUMPTION_PER_MOVE;
                console.log(`GameScene: Fuel consumed. Remaining: ${this.fuel}`);
                this.updateFuelDisplay(); // Обновляем UI
                this.updateInfoText();

                // Устанавливаем состояние сцены (логика сцены)
                this.isMoving = true;
                this.prevDistanceToTarget = undefined; // Сброс детектора промаха

                 // Добавляем ход в историю (данные получены от контроллера)
                this.movesHistory.push(result.moveData);
                console.log("GameScene: Move initiated via controller.");
            } else {
                 console.log("GameScene: Click did not initiate a move via controller.");
            }
        }, this);


        // --- Настройка физики и столкновений ---
        this.physics.add.overlap(this.car, this.obstaclesGroup, this.handleCollision, null, this);
        this.physics.add.overlap(this.car, this.collectibleGroup, this.handleCollectCube, null, this);
        this.physics.add.overlap(this.car, this.fuelPickupGroup, this.handleCollectFuelPickup, null, this);

        // --- Камеры ---
        this.cameras.main.startFollow(this.car, true, 0.05, 0.05);
        this.cameras.main.setZoom(2);
        this.cameras.main.setDeadzone(50, 50); // Мертвая зона для камеры

        // UI Камера
        this.uiCamera = this.cameras.add(0, 0, GAME_WIDTH, GAME_HEIGHT);
        this.uiCamera.setScroll(0, 0).setZoom(1);
        // Игнорирование игровых объектов UI камерой
        this.uiCamera.ignore([
            this.backgroundTile,
            this.ghostCar, // Управляется контроллером, но создается здесь
            this.car,
            this.obstaclesGroup.getChildren(),
             // Фильтруем активные пикапы перед игнорированием
             ...this.fuelPickupGroup.getChildren().filter(c => c.active),
            this.collectibleGroup.getChildren(),
            this.controlArcGraphics, // Управляется контроллером
            this.trajectoryGraphics, // Управляется контроллером
            this.snapCursor          // Управляется контроллером
        ]);

        // Игнорирование UI объектов основной камерой
        const mainCameraIgnoreList = [
            this.infoText, this.levelText, this.fuelText,
            this.playAgainButton, this.restartButtonObject, this.winText,
            this.nextLevelButton, this.restartLevelText // nextLevelButton может быть null
        ].filter(item => item); // Убираем null/undefined из списка
        if (mainCameraIgnoreList.length > 0) {
             this.cameras.main.ignore(mainCameraIgnoreList);
        }

        // --- Стрелка портала (UI элемент) ---
         this.portalArrow = this.add.sprite(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'arrow')
             .setDepth(200)
             .setScrollFactor(0) // Остается на месте в UI
             .setVisible(false)
             .setScale(1.2);
         this.uiCamera.ignore(this.portalArrow); // Игнорируется основной камерой
         this.cameras.main.ignore(this.portalArrow); // Убедимся что игнорируется

        // --- Отладочные контролы ---
        this.setupDebugControls();
        this.input.keyboard.enabled = true;

        // --- Первая отрисовка состояния контроллера ---
        this.calculateAndDrawState(); // Вызовет arcController.drawState()

        console.log("Game Scene create() finished.");
    }

    // --- Генерация уровня (Остается в сцене) ---

    createLevel() {
        console.log("Creating level obstacles, border, and cube...");
        // Очистка старых групп
        if (this.obstaclesGroup) this.obstaclesGroup.clear(true, true);
        if (this.collectibleGroup) this.collectibleGroup.clear(true, true);
        if (this.fuelPickupGroup) this.fuelPickupGroup.clear(true, true);

        if (!this.noise) {
            console.error("Noise generator not initialized!");
            return;
        }
        const noiseGenerator = this.noise;
        const scale = NOISE_SCALE;
        const threshold = this.currentObstacleThreshold;
        const startClearRadius = GRID_CELL_SIZE * START_AREA_CLEAR_RADIUS_FACTOR;

        const gridWidth = Math.floor(REAL_GAME_WIDTH / GRID_CELL_SIZE);
        const gridHeight = Math.floor(REAL_GAME_HEIGHT / GRID_CELL_SIZE);
        if (gridHeight <= 0 || gridWidth <= 0) {
            console.error("Invalid grid dimensions:", gridWidth, gridHeight); return;
        }
        const occupiedCells = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(false));

        // Очистка стартовой зоны
        const startGridX = Math.floor((REAL_GAME_WIDTH / 2) / GRID_CELL_SIZE);
        const startGridY = Math.floor((REAL_GAME_HEIGHT / 2) / GRID_CELL_SIZE);
        const clearRadiusGrid = Math.ceil(startClearRadius / GRID_CELL_SIZE);
        for (let dy = -clearRadiusGrid; dy <= clearRadiusGrid; dy++) {
            for (let dx = -clearRadiusGrid; dx <= clearRadiusGrid; dx++) {
                const checkX = startGridX + dx;
                const checkY = startGridY + dy;
                if (checkX >= 0 && checkX < gridWidth && checkY >= 0 && checkY < gridHeight) {
                    if (Phaser.Math.Distance.Between(startGridX, startGridY, checkX, checkY) <= clearRadiusGrid) {
                        occupiedCells[checkY][checkX] = true; // Помечаем как занятую для генерации
                    }
                }
            }
        }

        // Генерация препятствий по шуму
        for (let gy = 0; gy < gridHeight; gy++) {
            for (let gx = 0; gx < gridWidth; gx++) {
                const cellCenterX = gx * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                const cellCenterY = gy * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                if (occupiedCells[gy][gx]) continue; // Пропускаем стартовую зону
                if (noiseGenerator.noise2D(cellCenterX / scale, cellCenterY / scale) > threshold) {
                    const obstacle = this.obstaclesGroup.create(cellCenterX, cellCenterY, OBSTACLE_IMAGE_KEY);
                    obstacle.setScale(1); // Убедитесь, что масштаб правильный
                    occupiedCells[gy][gx] = true;
                }
            }
        }
        console.log(`Generated ${this.obstaclesGroup.getLength()} obstacles from noise.`);

        // Генерация границ
        let borderObstaclesCount = 0;
        // ... (код генерации границ остался без изменений) ...
         for (let gx = 0; gx < gridWidth; gx++) {
            const topX = gx * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
            const topY = GRID_CELL_SIZE / 2;
            const bottomY = (gridHeight - 1) * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
            if (!occupiedCells[0][gx]) {
                this.obstaclesGroup.create(topX, topY, OBSTACLE_IMAGE_KEY).setScale(1);
                occupiedCells[0][gx] = true;
                borderObstaclesCount++;
            }
            if (gridHeight > 1 && !occupiedCells[gridHeight - 1][gx]) {
                this.obstaclesGroup.create(topX, bottomY, OBSTACLE_IMAGE_KEY).setScale(1);
                occupiedCells[gridHeight - 1][gx] = true;
                borderObstaclesCount++;
            }
        }
        for (let gy = 1; gy < gridHeight - 1; gy++) {
            const leftX = GRID_CELL_SIZE / 2;
            const leftY = gy * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
            const rightX = (gridWidth - 1) * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
            if (!occupiedCells[gy][0]) {
                this.obstaclesGroup.create(leftX, leftY, OBSTACLE_IMAGE_KEY).setScale(1);
                occupiedCells[gy][0] = true;
                borderObstaclesCount++;
            }
            if (gridWidth > 1 && !occupiedCells[gy][gridWidth - 1]) {
                this.obstaclesGroup.create(rightX, leftY, OBSTACLE_IMAGE_KEY).setScale(1);
                occupiedCells[gy][gridWidth - 1] = true;
                borderObstaclesCount++;
            }
        }
        console.log(`Added ${borderObstaclesCount} border obstacles.`);
        this.obstaclesGroup.setDepth(-1); // Под фон? Или над?
        console.log(`Total obstacles on level: ${this.obstaclesGroup.getLength()}.`);

        // Спавн портала (куба)
        this.spawnCube(occupiedCells, gridWidth, gridHeight);

        // Сохраняем для спавна топлива
        this.occupiedCellsForSpawning = occupiedCells;
        this.gridWidthForSpawning = gridWidth;
        this.gridHeightForSpawning = gridHeight;
    }

    spawnCube(occupiedCells, gridWidth, gridHeight) {
        // ... (код спавна портала остался без изменений) ...
         if (!this.collectibleGroup) {
            console.error("Collectible group not initialized!");
            return;
        }
        let cubeSpawned = false;
        let attempts = 0;
        const maxAttempts = gridWidth * gridHeight;

        const startGridX = Math.floor((REAL_GAME_WIDTH / 2) / GRID_CELL_SIZE);
        const startGridY = Math.floor((REAL_GAME_HEIGHT / 2) / GRID_CELL_SIZE);
        const minSpawnDistCells = 8; // Минимальное расстояние в клетках от старта

        while (!cubeSpawned && attempts < maxAttempts) {
            const randomGridX = Phaser.Math.Between(0, gridWidth - 1);
            const randomGridY = Phaser.Math.Between(0, gridHeight - 1);

            // Проверяем, что ячейка свободна
            if (
                randomGridY >= 0 && randomGridY < occupiedCells.length &&
                randomGridX >= 0 && randomGridX < occupiedCells[randomGridY].length &&
                !occupiedCells[randomGridY][randomGridX]
            ) {
                 // Проверяем расстояние от стартовой точки
                const distanceInCells = Phaser.Math.Distance.Between(randomGridX, randomGridY, startGridX, startGridY);
                if (distanceInCells >= minSpawnDistCells) {
                    const cubeX = randomGridX * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                    const cubeY = randomGridY * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;

                    const portalSprite = this.collectibleGroup.create(cubeX, cubeY, PORTAL_KEY);
                    if(portalSprite) {
                         portalSprite.setOrigin(0.5).setDepth(0);
                         portalSprite.setScale(1.5); // Или другой масштаб
                         // Анимация пульсации
                         this.tweens.add({
                             targets: portalSprite,
                             scaleY: portalSprite.scaleY * 1.1,
                             scaleX: portalSprite.scaleX * 0.9,
                             yoyo: true,
                             repeat: -1,
                             ease: 'Sine.easeInOut',
                             duration: 800
                         });
                         this.cube = portalSprite; // Сохраняем ссылку
                         occupiedCells[randomGridY][randomGridX] = true; // Помечаем ячейку как занятую
                         cubeSpawned = true;
                         console.log(`Portal spawned at grid (${randomGridX}, ${randomGridY})`);
                    } else {
                        console.error("Failed to create portal sprite.");
                        break; // Прерываем цикл, если спрайт не создался
                    }
                }
            }
            attempts++;
        }
        if (!cubeSpawned) {
            console.warn(`Could not find a suitable free cell for the portal after ${maxAttempts} attempts!`);
        }
    }

    spawnFuelPickup(occupiedCells, gridWidth, gridHeight) {
       // ... (код спавна топлива остался без изменений) ...
        if (!this.fuelPickupGroup || !occupiedCells) {
            console.error("Fuel pickup group or occupiedCells not initialized!");
            return;
        }
        let pickupSpawned = false;
        let attempts = 0;
        const maxAttempts = gridWidth * gridHeight / 2; // Меньше попыток, чем для портала

        console.log("Attempting to spawn fuel pickup...");
        while (!pickupSpawned && attempts < maxAttempts) {
            const randomGridX = Phaser.Math.Between(0, gridWidth - 1);
            const randomGridY = Phaser.Math.Between(0, gridHeight - 1);
            // Проверяем, что ячейка существует и свободна
            if (
                randomGridY >= 0 && randomGridY < occupiedCells.length &&
                randomGridX >= 0 && randomGridX < occupiedCells[randomGridY].length &&
                !occupiedCells[randomGridY][randomGridX]
            ) {
                const pickupX = randomGridX * GRID_CELL_SIZE + GRID_CELL_SIZE / 2; // Центр ячейки
                const pickupY = randomGridY * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                const pickup = this.fuelPickupGroup.create(pickupX, pickupY, FUEL_PICKUP_KEY);
                if (pickup) {
                    pickup.setOrigin(0.5).setDepth(0);
                    pickup.setDisplaySize(GRID_CELL_SIZE * 0.8, GRID_CELL_SIZE * 0.8); // Чуть меньше ячейки
                    // Анимация
                    this.tweens.add({
                        targets: pickup,
                        scale: pickup.scale * 1.1, // Используем текущий scale
                        yoyo: true,
                        repeat: -1,
                        ease: 'Sine.easeInOut',
                        duration: 700
                    });
                    occupiedCells[randomGridY][randomGridX] = true; // Помечаем ячейку как занятую
                    pickupSpawned = true;
                    console.log(`Fuel pickup spawned at grid (${randomGridX}, ${randomGridY})`);
                } else {
                    console.error("Failed to create fuel pickup sprite.");
                    break; // Прерываем, если спрайт не создался
                }
            }
            attempts++;
        }
        if (!pickupSpawned) {
            console.warn(`Could not find a free cell to spawn fuel pickup after ${attempts} attempts.`);
        }
    }

    // --- Обновление UI (Остается в сцене) ---

    updateFuelDisplay() {
        // ... (код остался без изменений) ...
        if (!this.fuelText || !this.fuelText.active) return;
        let fuelString = `FUEL: ${this.fuel}`;
        this.fuelText.setFill(this.fuel <= FUEL_LOW_THRESHOLD ? FUEL_COLOR_LOW : FUEL_COLOR_NORMAL);
        try {
            this.fuelText.setText(fuelString);
        } catch (e) {
            console.warn("Error updating fuel text:", e);
        }
    }

    updateInfoText() {
       // ... (код остался без изменений, т.к. берет данные из this.car и this.fuel) ...
        if (!this.infoText || !this.car || !this.infoText.active) return;
        const speed = this.car.getData('speed') ?? 0;
        const redCooldown = this.car.getData('redCooldown') ?? 0;
        const accelDisabled = this.car.getData('accelDisabled') ?? false;
        const currentFuel = this.fuel;
        let statusText = '';
        if (this.gameOver) {
            statusText = 'GAME OVER';
        } else if (this.levelComplete) {
            statusText = 'Level Complete!';
        } else if (this.isMoving) {
            statusText = 'Moving...';
        } else {
            statusText = 'Ready for input';
        }
        const cooldownText = redCooldown > 0 ? ` | Red CD: ${redCooldown}` : '';
        const accelText = accelDisabled ? ' | ACCEL OFF' : '';
        const textLines = [
            `Speed: ${speed.toFixed(1)}${cooldownText}${accelText}`,
            `Fuel: ${currentFuel}`,
            statusText
        ];
        try {
            if (this.infoText.active) { // Дополнительная проверка активности
                this.infoText.setText(textLines);
            }
        } catch (e) {
            console.warn("Error updating info text:", e);
        }
    }

    // --- Обработка событий игры (Остается в сцене) ---

    handleCollectCube(car, cube) {
        if (!cube || !cube.active || this.levelComplete || this.gameOver) return;
        console.log(`Cube collected! Level ${this.currentLevel} Complete!`);
        this.levelComplete = true;

        // Останавливаем машину и анимации
        this.tweens.killTweensOf(cube);
        cube.destroy();
        this.cube = null; // Убираем ссылку
        if (this.isMoving && this.car?.body) {
            this.tweens.killTweensOf(this.car);
            this.car.body.stop();
            if (this.physics.world) this.physics.world.destination = null;
            this.isMoving = false; // Устанавливаем флаг
        }
        if (this.car?.body) this.car.body.enable = false; // Отключаем физику машины

        // Очищаем визуальные элементы контроллера
        if (this.arcController) this.arcController.clearVisuals();

        // Отключаем ввод
        this.input.off('pointerdown');
        this.input.off('pointermove');
        this.input.keyboard.enabled = false;

        // Отображаем UI победы
        if (this.winText) this.winText.setVisible(true);
        // Показываем нужную кнопку (Next или Play Again)
        if (this.currentLevel >= TOTAL_LEVELS) {
            if (this.winText) this.winText.setText('YOU WIN!').setVisible(true);
            if (this.playAgainButton) this.playAgainButton.setVisible(true);
            if (this.nextLevelButton) this.nextLevelButton.setVisible(false);
        } else {
             if (this.winText) this.winText.setText('LEVEL COMPLETE!').setVisible(true);
             if (this.nextLevelButton) this.nextLevelButton.setVisible(true);
             if (this.playAgainButton) this.playAgainButton.setVisible(false);
        }

        // Запускаем реплей
        this.startReplay();
        if (this.cameras.main) this.cameras.main.flash(400, WIN_FLASH_COLOR);
        this.updateInfoText(); // Обновляем статус в инфо
    }

    handleCollectFuelPickup(car, pickup) {
        if (!pickup || !pickup.active || this.levelComplete || this.gameOver) return;
        console.log("Collected fuel pickup!");

        // Освобождаем ячейку (если нужно для регенерации или др. логики)
        const gridX = Math.floor(pickup.x / GRID_CELL_SIZE);
        const gridY = Math.floor(pickup.y / GRID_CELL_SIZE);
        if (
            this.occupiedCellsForSpawning &&
            gridY >= 0 && gridY < this.gridHeightForSpawning &&
            gridX >= 0 && gridX < this.gridWidthForSpawning
        ) {
            this.occupiedCellsForSpawning[gridY][gridX] = false;
        }

        this.tweens.killTweensOf(pickup); // Убиваем анимацию
        pickup.destroy(); // Уничтожаем объект
        this.fuel = Math.min(this.fuel + FUEL_GAIN_ON_PICKUP, INITIAL_FUEL); // Добавляем топливо, не превышая максимум
        console.log(`Fuel increased to: ${this.fuel}`);
        this.updateFuelDisplay(); // Обновляем UI
        this.updateInfoText();
    }

    triggerGameOver(message) {
        if (this.gameOver || this.levelComplete) return; // Предотвращаем повторный вызов
        this.gameOver = true;
        this.isMoving = false; // Останавливаем движение

        console.log("GAME OVER:", message);
        // Останавливаем машину
        if (this.car) {
            this.tweens.killTweensOf(this.car);
            if (this.car.body) {
                this.car.body.stop();
                this.car.body.enable = false; // Отключаем физику
            }
        }
        if (this.physics.world) this.physics.world.destination = null;

        // Очищаем визуалы контроллера
         if (this.arcController) this.arcController.clearVisuals();

        // Отключаем ввод
        this.input.off('pointerdown');
        this.input.off('pointermove');
        this.input.keyboard.enabled = false;

        // Показываем сообщение
        if (this.restartLevelText) this.restartLevelText.setText(message).setVisible(true);

        // Эффекты
        if (this.cameras.main) {
            this.cameras.main.flash(FLASH_DURATION, FLASH_COLOR);
            this.cameras.main.shake(SHAKE_DURATION, SHAKE_INTENSITY);
        }

        // Рестарт с задержкой
        this.time.delayedCall(RESTART_DELAY, () => {
             if (this.scene.isActive(this.scene.key)) this.scene.restart();
        });
    }

    handleCollision(car, obstacle) {
        // Вызываем triggerGameOver только если машина двигалась и столкнулась с препятствием из группы
        if (this.isMoving && !this.levelComplete && !this.gameOver && this.car?.body && this.obstaclesGroup && this.obstaclesGroup.contains(obstacle)) {
            console.log("Collision detected!");
            this.triggerGameOver(`CRASH! LEVEL ${this.currentLevel}`);
        }
    }

    handleOutOfFuel() {
        if (this.gameOver || this.levelComplete) return;
        console.log("Fuel depleted!");
        this.triggerGameOver(`OUT OF FUEL! LEVEL ${this.currentLevel}`);
    }

    startNextLevel() {
        if (!this.levelComplete || this.currentLevel >= TOTAL_LEVELS) return;
        if (this.nextLevelButton) this.nextLevelButton.disableInteractive(); // Блокируем повторное нажатие

        console.log("Starting next level...");
        const nextLevel = this.currentLevel + 1;
        // Уменьшаем порог для усложнения (но не ниже минимума)
        const nextObstacleThreshold = Math.max(MIN_OBSTACLE_THRESHOLD, this.currentObstacleThreshold - OBSTACLE_THRESHOLD_DECREMENT);

        // Сохраняем новые параметры в реестре для следующего запуска сцены
        this.registry.set('currentLevel', nextLevel);
        this.registry.set('obstacleThreshold', nextObstacleThreshold);

        // Перезапускаем текущую сцену (она возьмет новые данные из реестра)
        if (this.scene.isActive(this.scene.key)) this.scene.restart();
    }

    // --- Метод Update (Цикл игры) ---

    update(time, delta) {
        if (this.gameOver || this.levelComplete || !this.car || !this.car.body || !this.car.active) {
             // Если игра окончена или машины нет, ничего не делаем
             // Можно дополнительно убедиться, что визуалы контроллера скрыты
             if (this.gameOver || this.levelComplete) {
                  if(this.arcController) this.arcController.clearVisuals();
             }
             return;
        }

        // Проверка завершения движения moveTo
        if (this.isMoving && this.physics.world?.destination) {
            const destination = this.physics.world.destination;
            const distanceToTarget = Phaser.Math.Distance.Between(this.car.x, this.car.y, destination.x, destination.y);
            const speed = this.car.body.velocity.length(); // Текущая скорость физического тела

             // Проверка на промах (overshoot)
             if (this.prevDistanceToTarget !== undefined) {
                 // Если дистанция начала увеличиваться, значит промахнулись
                 // или скорость почти нулевая и можем застрять
                 if (distanceToTarget > this.prevDistanceToTarget + 1 && speed > 1) { // Добавил +1 и speed>1 для стабильности
                     console.warn("Overshoot detected? Snapping to destination.");
                     this.car.body.reset(destination.x, destination.y); // Ставим точно в цель
                     this.finishMove(); // Завершаем ход
                     return; // Выходим из update
                 }
             }

            // Проверка достижения цели (близко к точке ИЛИ скорость почти 0)
            // Увеличил порог скорости для большей надежности
            if (distanceToTarget < STOP_DISTANCE_THRESHOLD || (speed < 5 && speed > 0) ) {
                 this.car.body.reset(destination.x, destination.y); // Ставим точно в цель
                 this.finishMove(); // Завершаем ход
                 return; // Выходим из update
            }

            // Сохраняем текущую дистанцию для следующего кадра (для детекции промаха)
            this.prevDistanceToTarget = distanceToTarget;

        } else if (!this.isMoving) {
             // Если не двигаемся, обновляем инфо и сбрасываем детектор промаха
             this.updateInfoText(); // Обновляем инфо-текст, пока стоим
             this.prevDistanceToTarget = undefined;
        }

        // --- Логика стрелки портала (остается в сцене) ---
        if (!this.cube || !this.cube.active) { // Если портала нет (собран или не создан)
             if (this.portalArrow?.visible) this.portalArrow.setVisible(false);
             // Убедимся, что нет ошибки, если portalArrow еще не создан
        } else { // Если портал есть
             const camera = this.cameras.main;
             const inCameraView = camera.worldView.contains(this.cube.x, this.cube.y);

             if (inCameraView) { // Если портал виден
                 if (this.portalArrow?.visible) this.portalArrow.setVisible(false);
             } else { // Если портал за экраном
                 if (this.portalArrow && !this.portalArrow.visible) this.portalArrow.setVisible(true);

                 // Рассчитываем позицию и угол стрелки (относительно центра ЭКРАНА)
                 const screenCenterX = this.cameras.main.width / 2; // Центр UI камеры
                 const screenCenterY = this.cameras.main.height / 2;

                  // Получаем позицию портала относительно центра камеры
                 const portalWorldPos = new Phaser.Math.Vector2(this.cube.x, this.cube.y);
                 const carWorldPos = new Phaser.Math.Vector2(this.car.x, this.car.y); // Используем позицию машины как центр "мира" для угла
                 //const angleRad = Phaser.Math.Angle.Between(screenCenterWorldX, screenCenterWorldY, this.cube.x, this.cube.y); // Угол от центра мира камеры
                 const angleRad = Phaser.Math.Angle.Between(carWorldPos.x, carWorldPos.y, portalWorldPos.x, portalWorldPos.y); // Угол от машины к порталу

                 // Расчет позиции стрелки на краю экрана (окружность)
                 const margin = 50; // Отступ от края
                 const radius = Math.min(this.cameras.main.width, this.cameras.main.height) / 2 - margin;

                 const arrowScreenX = screenCenterX + Math.cos(angleRad) * radius;
                 const arrowScreenY = screenCenterY + Math.sin(angleRad) * radius;

                 if(this.portalArrow) {
                      this.portalArrow.setPosition(arrowScreenX, arrowScreenY);
                      const angleDeg = Phaser.Math.RadToDeg(angleRad); // Не вычитаем 90, т.к. спрайт стрелки смотрит вправо (0 градусов)
                      this.portalArrow.setAngle(angleDeg);
                 }
             }
        }

        // --- Смещение камеры для слежения (остается в сцене) ---
         if (this.car && this.cameras.main.deadzone) { // Проверяем наличие deadzone
             const offsetDistance = -30; // Как далеко "за спиной" машины будет центр камеры
             const angleRad = Phaser.Math.DegToRad(this.car.angle);
             const offsetX = Math.cos(angleRad) * offsetDistance;
             const offsetY = Math.sin(angleRad) * offsetDistance;
             this.cameras.main.setFollowOffset(offsetX, offsetY);
         }
    }

    // --- Завершение хода (Обновлено) ---
    finishMove() {
        if(!this.isMoving) return; // На всякий случай, если вызвали повторно

        // 1. Применяем запланированное состояние машины (устанавливается контроллером)
        const nextSpeed = this.car.getData('nextSpeed');
        const nextRedCooldown = this.car.getData('nextRedCooldown');
        const nextAccelDisabled = this.car.getData('nextAccelDisabled');

        if (nextSpeed !== undefined) this.car.setData('speed', nextSpeed);

        let currentRedCooldown = this.car.getData('redCooldown') ?? 0;
        if (nextRedCooldown !== undefined) { // Если контроллер задал новое значение
            currentRedCooldown = nextRedCooldown;
        } else if (currentRedCooldown > 0) { // Иначе, если был кулдаун, уменьшаем
             currentRedCooldown--;
        }
        this.car.setData('redCooldown', currentRedCooldown);

        // Ускорение блокируется только на ход ПОСЛЕ red-зоны
        const accelDisabledForThisTurn = (nextAccelDisabled === true);
        this.car.setData('accelDisabled', accelDisabledForThisTurn);

        // Сбрасываем запланированные значения
        this.car.setData('nextSpeed', undefined);
        this.car.setData('nextRedCooldown', undefined);
        this.car.setData('nextAccelDisabled', undefined);

        // 2. Обновляем состояние сцены
        this.isMoving = false; // Движение завершено
        if (this.physics.world) this.physics.world.destination = null; // Сбрасываем цель физики
        this.prevDistanceToTarget = undefined; // Сброс детектора промаха

        console.log("GameScene: Turn finished. Current State - Speed:", this.car.getData('speed').toFixed(2), "RedCD:", this.car.getData('redCooldown'), "AccelDisabled:", this.car.getData('accelDisabled'));

        // 3. Проверяем на конец топлива ПОСЛЕ завершения хода
        if (this.fuel <= 0 && !this.gameOver && !this.levelComplete) {
            this.handleOutOfFuel();
            return; // Выходим, т.к. игра закончилась
        }

        // 4. Сбрасываем и обновляем контроллер и UI для следующего хода
        if (this.scene.isActive(this.scene.key) && !this.levelComplete && !this.gameOver && this.arcController) {
             const pointer = this.input.activePointer; // Получаем текущее положение мыши
             this.arcController.resetForNextTurn(pointer); // Передаем его контроллеру для обновления ховера/призрака
             this.updateInfoText(); // Обновляем текст с новым состоянием
        } else if(this.arcController) {
             // Если игра закончилась, пока проверяли топливо, просто очищаем визуалы
             this.arcController.clearVisuals();
             this.updateInfoText();
        }
    }


    // --- Логика реплея (Остается в сцене) ---

    startReplay() {
        if (!this.movesHistory || this.movesHistory.length === 0) {
            console.log("No moves to replay.");
            return;
        }
        if (this.car) this.car.setVisible(false); // Скрываем основную машину

        // Очищаем визуалы контроллера перед реплеем
        if (this.arcController) this.arcController.clearVisuals();

        // Создаем машину для реплея
        this.replayCar = this.add.sprite(0, 0, CAR_PLAYER_KEY)
             .setDepth(this.car ? this.car.depth + 1 : 11) // Чуть выше основной
             .setScale(this.car ? this.car.scale : 0.3);
        // Важно: UI камера ДОЛЖНА игнорировать replayCar
        if (this.uiCamera) {
             this.uiCamera.ignore(this.replayCar);
        }

        // Камера следит за реплей-машиной
        this.cameras.main.startFollow(this.replayCar, true, 0.05, 0.05); // Плавнее?
        this.cameras.main.setFollowOffset(0,0); // Сбрасываем смещение для реплея

        // Устанавливаем начальную позицию
        const firstMove = this.movesHistory[0];
        this.replayCar.setPosition(firstMove.startX, firstMove.startY);
        this.replayCar.setAngle(firstMove.fromAngleDeg);

        this.currentReplayIndex = 0;
        console.log("Replay started...");
        this.replayNextMove(); // Запускаем первый ход реплея
    }

    replayNextMove() {
        if (!this.replayCar || !this.replayCar.active) {
             console.log("Replay stopped: replay car removed.");
             this.cameras.main.stopFollow(); // Прекращаем слежение
             return;
        }
        if (this.currentReplayIndex >= this.movesHistory.length) {
            console.log("Replay finished.");
            // Возможно, скрыть реплей-машину или вернуть камеру на место?
             this.replayCar.setVisible(false);
             // this.cameras.main.startFollow(this.car); // Если нужно вернуть на невидимую основную
             this.cameras.main.stopFollow();
            return;
        }

        const step = this.movesHistory[this.currentReplayIndex];
        this.currentReplayIndex++;

        // Устанавливаем начальные параметры для твина (на случай прерывания)
        this.replayCar.setPosition(step.startX, step.startY);
        this.replayCar.setAngle(step.fromAngleDeg);

        // Длительность хода в реплее - можно сделать фиксированной или взять из истории
        // const duration = 500; // Фиксированная
        const duration = Math.max(step.turnDuration, step.moveTime); // Берем максимальное время поворота/движения

        console.log(`Replaying move ${this.currentReplayIndex}: duration ${duration.toFixed(0)}ms`);

        this.tweens.add({
            targets: this.replayCar,
            x: step.targetX,
            y: step.targetY,
            angle: step.finalAngleDeg, // Используем конечный угол из истории
            duration: duration,
            ease: 'Linear', // Или другая интерполяция
            onComplete: () => {
                // Небольшая пауза между ходами?
                // this.time.delayedCall(100, this.replayNextMove, [], this);
                 this.replayNextMove(); // Сразу следующий ход
            }
        });
    }

    // --- Отладка (Остается в сцене) ---

    setupDebugControls() {
       // ... (код без изменений, если он не трогал методы, ушедшие в контроллер) ...
        if (!this.input?.keyboard) {
            console.warn("Keyboard input not available");
            return;
        }
        // Очищаем старые обработчики, если были
        this.input.keyboard.off('keydown-W');
        this.input.keyboard.off('keydown-S');
        this.input.keyboard.off('keydown-A');
        this.input.keyboard.off('keydown-D');
        this.input.keyboard.off('keydown-P');
        this.input.keyboard.off('keydown-R');
        this.input.keyboard.off('keydown-F');

        const checkDebugInput = () => this.car?.active && !this.isMoving && !this.levelComplete && !this.gameOver;

        this.input.keyboard.on('keydown-W', () => {
            if (!checkDebugInput()) return;
            let s = Phaser.Math.Clamp((this.car.getData('speed') ?? MIN_SPEED) + 0.5, MIN_SPEED, MAX_SPEED);
            this.car.setData('speed', s);
            this.calculateAndDrawState(); // Перерисовываем контроллер
        });
        this.input.keyboard.on('keydown-S', () => {
            if (!checkDebugInput()) return;
            let s = Phaser.Math.Clamp((this.car.getData('speed') ?? MIN_SPEED) - 0.5, MIN_SPEED, MAX_SPEED);
            this.car.setData('speed', s);
            this.calculateAndDrawState();
        });
        this.input.keyboard.on('keydown-A', () => {
            if (!checkDebugInput()) return;
            this.car.angle -= 15;
            this.calculateAndDrawState();
        });
        this.input.keyboard.on('keydown-D', () => {
             if (!checkDebugInput()) return;
             this.car.angle += 15;
             this.calculateAndDrawState();
        });
        // Пропуск уровня
        this.input.keyboard.on('keydown-P', () => {
            if (checkDebugInput() && this.cube?.active) {
                 console.log("Debug: Skipping level...");
                 this.handleCollectCube(this.car, this.cube); // Вызываем сбор куба
            }
        });
        // Сброс сложности (для следующего рестарта)
        this.input.keyboard.on('keydown-R', () => {
            console.log("Debug: Resetting obstacle threshold in registry to initial value for next level restart.");
            this.registry.set('obstacleThreshold', INITIAL_OBSTACLE_THRESHOLD);
        });
        // Добавить топлива
        this.input.keyboard.on('keydown-F', () => {
            if (checkDebugInput()) {
                this.fuel = Math.min(this.fuel + 5, INITIAL_FUEL);
                console.log(`Debug: Added fuel. Current: ${this.fuel}`);
                this.updateFuelDisplay();
                this.updateInfoText();
            }
        });
    }

     // --- Новый метод для делегирования ---
     calculateAndDrawState() {
         if (!this.car || !this.car.body || !this.arcController) {
              console.warn("Cannot draw state - car or controller missing");
              return;
         }

         if (this.isMoving || this.levelComplete || this.gameOver) {
              // Если машина движется или игра окончена, контроллер должен скрыть свои элементы
              this.arcController.clearVisuals();
         } else {
              // Иначе, просим контроллер отрисовать свое текущее состояние (дугу)
              this.arcController.drawState();
         }
         // Обновляем текстовую информацию в любом случае
         this.updateInfoText();
     }


} // Конец класса GameScene 
 
 
=============================================================================== 
=== File: main.js 
=== Path: D:\Games\TopTrack\TopTrack Maze\main.js 
=============================================================================== 
 
// ==============================
// --- КОНФИГ ФЕЙЗЕРА И СТАРТ ---
// ==============================
const config = {
    type: Phaser.AUTO,
    width: GAME_WIDTH,
    height: GAME_HEIGHT,
    parent: 'phaser-game',
    scene: [MainMenuScene, GameScene], // <--- Проблемное место
    antialias: true,
    physics: {
        default: 'arcade',
        arcade: { debug: false }
    },
    resolution: window.devicePixelRatio || 1,
    render: { pixelArt: false }
};

window.onload = () => {
    if (typeof SimplexNoise === 'undefined') {
        console.error("SimplexNoise library is not loaded! Check index.html.");
        const gameContainer = document.getElementById('phaser-game');
        if (gameContainer) {
            // ... код обработки ошибки SimplexNoise ...
        }
    } else {
        const game = new Phaser.Game(config); // <--- Запуск игры
        console.log("Phaser Game instance created.");
    }
}; 
 
 
=============================================================================== 
=== File: MainMenuScene.js 
=== Path: D:\Games\TopTrack\TopTrack Maze\MainMenuScene.js 
=============================================================================== 
 
// ==============================
// --- КЛАСС СЦЕНЫ ГЛАВНОГО МЕНЮ ---
// ==============================
class MainMenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainMenuScene' });
    }

    preload() {
        console.log("Preloading Main Menu assets...");
        this.load.image(MAIN_BG_KEY, 'assets/MainBG.jpg');
        this.load.image(START_BUTTON_KEY, 'assets/STARTGAME.png');
    }

    create() {
        console.log("Creating Main Menu Scene...");
        this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2, MAIN_BG_KEY)
            .setDisplaySize(GAME_WIDTH, GAME_HEIGHT);

        const startButton = this.add.image(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 350, START_BUTTON_KEY)
            .setOrigin(0.5)
            .setInteractive({ useHandCursor: true });

        startButton.on('pointerdown', () => {
            console.log("Start button clicked!");
            this.registry.set('currentLevel', 1);
            this.registry.set('obstacleThreshold', INITIAL_OBSTACLE_THRESHOLD);
            this.scene.start('GameScene');
        });
    }
}
 
 
